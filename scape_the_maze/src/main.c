#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

typedef struct{
    int isWall;
    int hasPlayer;
    int isExit;
} MazeCell;

MazeCell** createMaze(int rows, int cols);
void init_maze(MazeCell** maze, int rows, int cols);
void free_malloc(MazeCell** maze, int rows);
void print_maze(MazeCell** maze, int rows, int cols);
bool move_player(MazeCell** maze, int rows, int cols, char direction); 
void generate_maze_paths(MazeCell** maze, int rows, int cols, int start_row, int start_col);

int main(){
    int rows, cols;
    printf("How many rows? ");
    scanf("%d", &rows);
    printf("How many columns? ");
    scanf("%d", &cols);

    MazeCell** maze = createMaze(rows, cols);
    init_maze(maze, rows, cols);
    generate_maze_paths(maze, rows, cols, 1, 1);

    
    srand(time(NULL));  // initialize random functionallity
    int player_row, player_col;
    do{
        player_row = rand() % rows;
        player_col = rand() % cols;
    } while (maze[player_row][player_col].isWall);
    maze[player_row][player_col].hasPlayer = true;


    int exit_row, exit_col;
    do{
        exit_row = rand() % rows;
        exit_col = rand() % cols;
    } while (maze[exit_row][exit_col].isWall || (exit_row == player_row && exit_col == player_col));
    maze[exit_row][exit_col].isExit = true;

    char direction;
    bool reached_exit = false;

    while(!reached_exit){
        print_maze(maze, rows, cols);
        printf("\nMove (w/a/s/d): ");
        scanf("%c", &direction);
        printf("\n");
        
        reached_exit = move_player(maze, rows, cols, direction);
        if(reached_exit){
            printf("Congratulations! You reached the exit!\n");
        }   
    }   

    free_malloc(maze, rows);
    return 0;
}

MazeCell** createMaze(int rows, int cols){
    MazeCell** maze = malloc(sizeof(MazeCell*) * rows);
    for (int i = 0; i < rows; i++){
        maze[i] = malloc(sizeof(MazeCell) * cols);
    }

    return maze;
}

void free_malloc(MazeCell** maze, int rows)
{
    for( int i = 0; i < rows; i++){
        free(maze[i]);
    }
    free(maze);
}

void init_maze(MazeCell** maze, int rows, int cols){
    for (int i = 0; i < rows; i++){
        for (int j = 0; j < cols; j++){
            maze[i][j].isWall = true;  // Maze initialized with all walls.
            maze[i][j].hasPlayer = false;
            maze[i][j].isExit = false;
        }
    }
}

void print_maze(MazeCell** maze, int rows, int cols){
    for (int i = 0; i < rows; i++){
        for(int j = 0; j < cols; j++)
        {
            if(maze[i][j].hasPlayer == true){
                printf("@");
            } else if(maze[i][j].isExit == true){
                printf("E");
            } else if(maze[i][j].isWall == true){
                printf("#");
            } else{
                printf(" ");
            }
        }
        printf("\n");
    }
    printf("\n");
}

bool move_player(MazeCell** maze, int rows, int cols, char direction){
    int current_row = -1, current_col = -1;

    for(int i = 0; i < rows; i++){
        for(int j = 0; j < cols; j++){
            if(maze[i][j].hasPlayer){
                current_row = i;
                current_col = j;
                break;
            }
        }
        if(current_row != -1) break;
    }

    int new_row = current_row, new_col = current_col;
    switch (direction){
        case 'w':
            new_row--;
            break;
        case 's':
            new_row++;
            break;
        case 'a':
            new_col--;
            break;
        case 'd':
            new_col++;
            break;
    }

    if(new_row < 0 || new_row > rows || new_col < 0 || new_col > cols){
        return false;
    }

    if(maze[new_row][new_col].isWall){
        return false;
    }

    maze[current_row][current_col].hasPlayer = false;
    maze[new_row][new_col].hasPlayer = true;

    return maze[new_row][new_col].isExit;
}

void generate_maze_paths(MazeCell** maze, int rows, int cols, int start_row, int start_col){
    // This function is "recusive", meaning that it uses itself. The start_row and start_col
    // are generated by this same function

    //Define directions array:
    int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    //Shaffle directions for rundmoness:
    for (int i = 0; i < 4; i++){
        int r = rand() % 4;
        int temp[2] = {directions[i][0], directions[i][1]};
        directions[i][0] = directions[r][0];
        directions[i][1] = directions[r][1];
        directions[r][0] = temp[0];
        directions[r][1] = temp[1];
    }

    //Starting cell is path:
    maze[start_row][start_col].isWall = false;

    //Try to carve a path in each direction
    for (int i = 0; i < 4; i++){
        int new_row = start_row + 2 * directions[i][0];
        int new_col = start_col + 2 * directions[i][1];

        if (new_row > 0 && new_row < rows - 1 && new_col > 0 && new_col < cols - 1 && maze[new_row][new_col].isWall){
            maze[start_row + directions[i][0]][start_col + directions[i][1]].isWall = false;
            generate_maze_paths(maze, rows, cols, new_row, new_col);
        }
    }

}

